---
description: Development workflow and best practices for Waidrin
globs: **/*.ts,**/*.tsx
---

# Waidrin Development Workflow

## Project Structure

Waidrin is a Next.js-based AI role-playing game engine with a headless backend and React frontend. The project follows a specific architecture pattern:

### Core Architecture
- **Engine**: [lib/engine.ts](mdc:lib/engine.ts) - Main game state machine and orchestration
- **State Management**: [lib/state.ts](mdc:lib/state.ts) - Zustand store with Immer for immutable updates
- **Backend**: [lib/backend.ts](mdc:lib/backend.ts) - LLM integration and API abstraction
- **Schemas**: [lib/schemas.ts](mdc:lib/schemas.ts) - Zod validation schemas for all data types
- **Prompts**: [lib/prompts.ts](mdc:lib/prompts.ts) - LLM prompt templates

### Directory Structure
- `app/` - Next.js 15 app router pages and layouts
- `components/` - Reusable React components
- `views/` - Page-level view components (Welcome, Chat, etc.)
- `lib/` - Core business logic and utilities
- `plugins/` - Plugin system for extending functionality
- `public/images/` - Static assets and AI-generated artwork

## Key Patterns

### State Machine
The game follows a strict view state machine: welcome → connection → genre → character → scenario → chat

### Event-Driven
All game events are typed and validated through Zod schemas

### Plugin System
Extensible architecture with plugin support for backends and custom functionality

### Immutable Updates
All state changes use Immer for safe, immutable updates

### Type Safety
Full TypeScript with strict validation using Zod schemas

## File Naming Conventions

- Components: PascalCase (e.g., `MainMenu.tsx`)
- Views: PascalCase (e.g., `CharacterSelect.tsx`)
- Utilities: camelCase (e.g., `backend.ts`)
- Schemas: camelCase (e.g., `schemas.ts`)

## Development Guidelines

### TypeScript Standards
- Always use strict TypeScript with `noEmit: true` for type checking
- All data validation uses Zod schemas from [lib/schemas.ts](mdc:lib/schemas.ts)
- Prefer type inference over explicit types when possible
- Use `WritableDraft<T>` for Immer state updates

### React Patterns
- Use `"use client"` directive for interactive components
- Default to server components when possible
- Use `useShallow` from zustand for performance optimization
- Always use the `setAsync` method for state updates that involve async operations

### Error Handling
- Use `isAbortError()` to detect user-initiated cancellations
- Wrap async operations in try-catch blocks
- Always provide user-friendly error messages

### Performance
- Use `throttle` from lodash for frequent updates
- Use `useShallow` for Zustand selectors
- Use React.memo for expensive components when needed

## Engine System

### Current Engine
- Linear state machine implementation
- Re-exports functions from [lib/engine-original.ts](mdc:lib/engine-original.ts)
- Located in [lib/engines/current/engine.ts](mdc:lib/engines/current/engine.ts)

### LangGraph Engine
- Graph-based state machine (in development)
- Located in [lib/engines/langgraph/src/](mdc:lib/engines/langgraph/src/)
- ⚠️ **UNCONFIRMED** - needs validation and testing

### Engine Switching
- Runtime switching between engines
- Managed by [lib/engines/index.ts](mdc:lib/engines/index.ts)
- All engines implement the same `GameEngine` interface

## Streaming Implementation

### Backend Trust Pattern
- Always trust the backend to accumulate complete responses
- The `backend.getNarration()` method handles complete text accumulation
- Do NOT manually accumulate streaming text in engine callbacks

### Immer Compliance
- Never mutate Immer drafts inside async callbacks
- Only mutate draft state within the main producer function
- Use separate variables for async accumulation, then assign to draft at the end

## Environment Configuration

### Environment Variables
- `OPENAI_API_URL` - Default API URL
- `OPENAI_API_KEY` - Default API Key  
- `OPENAI_MODEL` - Default Model
- All provide defaults but can be overridden at runtime

### Validation
- All environment variables validated through Zod schemas
- Invalid values cause application startup to fail
- Clear error messages for configuration issues

## Testing Approach

### Current Status
- ✅ Main streaming bug fixed
- ✅ Environment variables working
- ✅ Engine switching functional
- ⚠️ LangGraph engine needs validation
- ⚠️ Some upstream features may be missing

### Testing Guidelines
- Test each engine independently
- Verify streaming works without text loss
- Test environment variable configuration
- Validate state consistency across engines