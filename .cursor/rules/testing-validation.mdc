---
globs: **/*.test.ts,**/*.spec.ts,tests/**/*.ts
description: Testing patterns and validation strategies
---

# Testing and Validation

## Testing Strategy

Waidrin follows a comprehensive testing approach covering all major components:

- **Unit Tests**: Individual component and function testing
- **Integration Tests**: Engine and backend integration testing
- **End-to-End Tests**: Full game flow testing
- **Validation Tests**: Schema and data validation testing

## Testing Framework

### Current Setup
- **TypeScript**: Strict type checking with `noEmit: true`
- **Biome**: Linting and formatting
- **Zod**: Runtime validation and type safety
- **Jest**: Testing framework (to be implemented)

### Test Structure
```
tests/
├── unit/
│   ├── components/
│   ├── engines/
│   ├── state/
│   └── schemas/
├── integration/
│   ├── engine-switching/
│   ├── backend-integration/
│   └── state-management/
└── e2e/
    ├── game-flow/
    └── user-interactions/
```

## Unit Testing

### Component Testing
```typescript
// Component test example
import { render, screen } from '@testing-library/react';
import { MainMenu } from '@/components/MainMenu';

describe('MainMenu', () => {
  it('renders welcome message', () => {
    render(<MainMenu />);
    expect(screen.getByText('Welcome to Waidrin')).toBeInTheDocument();
  });
});
```

### Engine Testing
```typescript
// Engine test example
import { CurrentEngine } from '@/lib/engines/current/engine';

describe('CurrentEngine', () => {
  it('should execute game flow correctly', async () => {
    const engine = new CurrentEngine();
    const initialState = getInitialState();
    
    const result = await engine.execute(initialState);
    expect(result.view).toBe('welcome');
  });
});
```

### State Testing
```typescript
// State test example
import { useStateStore } from '@/lib/state';

describe('State Management', () => {
  it('should update view correctly', () => {
    const { getState } = useStateStore.getState();
    
    getState().set((state) => {
      state.view = 'chat';
    });
    
    expect(getState().view).toBe('chat');
  });
});
```

## Integration Testing

### Engine Switching
```typescript
// Engine switching test
import { switchEngine, getCurrentEngineType } from '@/lib/engine';

describe('Engine Switching', () => {
  it('should switch between engines', async () => {
    await switchEngine('current');
    expect(getCurrentEngineType()).toBe('current');
    
    await switchEngine('langgraph');
    expect(getCurrentEngineType()).toBe('langgraph');
  });
});
```

### Backend Integration
```typescript
// Backend integration test
import { getBackend } from '@/lib/backend';

describe('Backend Integration', () => {
  it('should handle streaming responses', async () => {
    const backend = getBackend();
    const prompt = { system: 'Test', user: 'Hello' };
    
    const response = await backend.getNarration(prompt, (token) => {
      // Verify streaming callback
      expect(token).toBeDefined();
    });
    
    expect(response).toBeDefined();
  });
});
```

## Validation Testing

### Schema Validation
```typescript
// Schema validation test
import { State, Character } from '@/lib/schemas';

describe('Schema Validation', () => {
  it('should validate valid state', () => {
    const validState = {
      view: 'welcome',
      world: { name: 'Test', description: 'Test world' },
      // ... other required fields
    };
    
    const result = State.safeParse(validState);
    expect(result.success).toBe(true);
  });
  
  it('should reject invalid state', () => {
    const invalidState = {
      view: 'invalid',
      // ... missing required fields
    };
    
    const result = State.safeParse(invalidState);
    expect(result.success).toBe(false);
  });
});
```

### Type Safety Testing
```typescript
// Type safety test
import type { State, Character } from '@/lib/schemas';

describe('Type Safety', () => {
  it('should infer correct types', () => {
    const state: State = {
      view: 'welcome',
      // ... other fields
    };
    
    // TypeScript should enforce correct types
    expect(state.view).toBe('welcome');
  });
});
```

## Error Handling Testing

### Abort Error Testing
```typescript
// Abort error test
import { isAbortError } from '@/lib/engine';

describe('Error Handling', () => {
  it('should detect abort errors', () => {
    const abortError = new Error('Aborted');
    expect(isAbortError(abortError)).toBe(true);
  });
});
```

### Async Error Testing
```typescript
// Async error test
describe('Async Error Handling', () => {
  it('should handle async errors gracefully', async () => {
    const engine = new CurrentEngine();
    
    await expect(engine.execute(invalidState)).rejects.toThrow();
  });
});
```

## Performance Testing

### State Update Performance
```typescript
// Performance test
describe('Performance', () => {
  it('should handle large state updates efficiently', () => {
    const start = performance.now();
    
    // Perform large state update
    getState().set((state) => {
      for (let i = 0; i < 1000; i++) {
        state.events.push({ type: 'test', data: i });
      }
    });
    
    const end = performance.now();
    expect(end - start).toBeLessThan(100); // Should complete in < 100ms
  });
});
```

## Development Guidelines

### Test Organization
- Group tests by functionality
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)
- Keep tests focused and independent

### Test Data
- Use factory functions for test data
- Create realistic test scenarios
- Test edge cases and error conditions
- Mock external dependencies

### Continuous Integration
- Run tests on every commit
- Ensure all tests pass before merging
- Monitor test coverage
- Set up automated testing pipeline