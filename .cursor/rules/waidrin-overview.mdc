---
description: Comprehensive overview of Waidrin architecture and development patterns
globs: lib/**/*.ts,app/**/*.tsx,components/**/*.tsx
---

# Waidrin Development Overview

## Project Summary

Waidrin is a Next.js-based AI role-playing game engine with a headless backend and React frontend. The project features multiple engine support, plugin extensibility, and comprehensive state management.

## Architecture Overview

### Core Components
- **Engine System**: Multiple game engines (current linear, LangGraph graph-based)
- **State Management**: Zustand with Immer for immutable updates
- **Backend Integration**: OpenAI and custom backend support with streaming
- **Plugin System**: Extensible architecture for custom functionality
- **Validation**: Zod v4 schemas for type safety and validation

### Key Files
- [lib/engine.ts](mdc:lib/engine.ts) - Main engine interface and switcher
- [lib/state.ts](mdc:lib/state.ts) - Core state management
- [lib/backend.ts](mdc:lib/backend.ts) - Backend integration
- [lib/schemas.ts](mdc:lib/schemas.ts) - Zod validation schemas
- [lib/engines/](mdc:lib/engines/) - Engine implementations

## Development Patterns

### TypeScript Standards
- Strict mode with `noEmit: true`
- Zod v4 for validation and type inference
- Immer for immutable state updates
- Full type safety throughout

### React Patterns
- Next.js 15 app router
- Server components by default
- Client components with `"use client"`
- Performance optimization with `useShallow`

### State Management
- Zustand store with Immer middleware
- `setAsync` for async state updates
- Persistent state with selective serialization
- Event-driven architecture

### Engine System
- Factory pattern for engine creation
- Runtime engine switching
- Unified interface across engines
- Backward compatibility maintained

## Key Features

### Multi-Engine Support
- Current engine: Linear state machine
- LangGraph engine: Graph-based state machine (in development)
- Runtime switching between engines
- Unified API across engines

### Streaming Implementation
- Backend trust pattern for response accumulation
- Real-time progress updates
- Immer-compliant state updates
- Error handling and recovery

### Plugin System
- Extensible architecture
- Custom backend support
- Event-driven plugin lifecycle
- Settings and configuration management

### Validation and Type Safety
- Comprehensive Zod schemas
- Runtime validation
- Type inference from schemas
- Error handling and recovery

## Development Workflow

### Getting Started
1. Set up environment variables
2. Install dependencies with `npm install`
3. Run development server with `npm run dev`
4. Access the application at `http://localhost:3000`

### Adding Features
1. Define Zod schemas in [lib/schemas.ts](mdc:lib/schemas.ts)
2. Add state management in [lib/state.ts](mdc:lib/state.ts)
3. Create components in `components/` or `views/`
4. Add engine logic if needed
5. Update prompts in [lib/prompts.ts](mdc:lib/prompts.ts)

### Testing
- Unit tests for components and functions
- Integration tests for engines and backends
- End-to-end tests for game flows
- Validation tests for schemas

## Current Status

### ‚úÖ Completed
- Core architecture and state management
- Current engine implementation
- Backend integration with streaming
- Plugin system foundation
- Engine switching system
- Comprehensive validation schemas

### ‚ö†Ô∏è In Progress
- LangGraph engine implementation (unconfirmed changes)
- Testing framework setup
- Documentation completion
- Performance optimization

### üîÑ Ongoing
- Bug fixes and improvements
- Feature development
- Plugin ecosystem
- Engine validation and testing

## Best Practices

### Code Quality
- Follow Biome configuration
- Use TypeScript strictly
- Implement comprehensive error handling
- Write clear, documented code

### Performance
- Use `useShallow` for Zustand selectors
- Implement proper caching strategies
- Optimize bundle size
- Monitor performance metrics

### Security
- Validate all inputs
- Handle errors gracefully
- Use secure communication
- Follow security best practices

### Maintainability
- Keep components focused and single-purpose
- Use clear naming conventions
- Document complex logic
- Follow established patterns

## Resources

### Documentation
- [Core Development](mdc:.cursor/rules/core-development.mdc)
- [Architecture Patterns](mdc:.cursor/rules/architecture-patterns.mdc)
- [Engine Development](mdc:.cursor/rules/engine-development.mdc)
- [State Management](mdc:.cursor/rules/state-management.mdc)
- [Backend Integration](mdc:.cursor/rules/backend-integration.mdc)
- [Testing and Validation](mdc:.cursor/rules/testing-validation.mdc)
- [Next.js Patterns](mdc:.cursor/rules/nextjs-patterns.mdc)
- [Plugin System](mdc:.cursor/rules/plugin-system.mdc)

### Key Dependencies
- Next.js 15 with app router
- React 19 with server components
- Zustand for state management
- Immer for immutable updates
- Zod v4 for validation
- OpenAI for LLM integration
- Radix UI for components