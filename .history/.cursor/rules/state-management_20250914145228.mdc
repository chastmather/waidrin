---
globs: lib/state.ts,lib/engine.ts,lib/schemas.ts
---

# State Management and Engine Rules

## State Store Architecture

- **Zustand + Immer**: Use Zustand with Immer middleware for immutable state updates
- **Async Operations**: Use `setAsync` with mutex for thread-safe async state updates
- **State Validation**: Always validate state with Zod schemas before and after updates
- **Persistence**: State is persisted to localStorage with selective serialization

## State Update Patterns

```typescript
// Synchronous updates
getState().set((state) => {
  state.property = newValue;
});

// Async updates (preferred for complex operations)
await getState().setAsync(async (state) => {
  const result = await someAsyncOperation();
  state.property = result;
});
```

## Engine State Machine

The game follows a strict state machine defined in [lib/engine.ts](mdc:lib/engine.ts):

1. **welcome** → **connection** → **genre** → **character** → **scenario** → **chat**
2. **back()** function reverses the state machine (except from chat)
3. **reset()** returns to initial state
4. **next()** advances the state machine with async operations

## Event System

- **Event Types**: All events are defined in [lib/schemas.ts](mdc:lib/schemas.ts)
- **Event Processing**: Events are processed sequentially and validated
- **Character References**: Automatic character reference detection in narration
- **Location Changes**: Trigger plugin callbacks and character updates

## Data Validation

- **Zod Schemas**: All data structures use Zod for validation
- **Type Safety**: Export types from schemas for TypeScript integration
- **Runtime Validation**: Parse all external data with Zod schemas
- **Error Handling**: Invalid data throws descriptive errors

## Plugin System

- **Plugin Interface**: Defined in [lib/state.ts](mdc:lib/state.ts)
- **Backend Plugins**: Can provide custom LLM backends
- **Location Hooks**: Plugins can react to location changes
- **State Access**: Plugins receive WritableDraft<State> for safe updates

## Performance Considerations

- **Throttling**: Use lodash throttle for frequent updates
- **Batch Updates**: Group related state changes together
- **Selective Updates**: Use shallow selectors to minimize re-renders
- **Async Mutex**: Prevent concurrent async state updates

## State Structure

```typescript
interface State {
  // Configuration
  apiUrl: string;
  apiKey: string;
  model: string;
  
  // Game State
  view: View;
  world: World;
  locations: Location[];
  characters: Character[];
  protagonist: Character;
  events: Event[];
  actions: Action[];
  
  // Settings
  generationParams: Record<string, unknown>;
  narrationParams: Record<string, unknown>;
}
```